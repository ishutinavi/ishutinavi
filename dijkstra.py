graph_matrix = [
    [0, 3, 0, 0, 5, 3],
    [3, 0, 8, 0, 0, 0],
    [0, 8, 0, 7, 0, 4],
    [0, 0, 7, 0, 6, 4],
    [5, 0, 0, 6, 0, 0],
    [3, 0, 4, 4, 0, 0],
]

max_top = len(graph_matrix) #определяем количество вершин в графе
start_top = int(input(f"Введите номер начальной вершины (1-{max_top}): ")) - 1 #запускаем окно, куда пользователь вводит интересуемую вершину для анализа, -1 для того, что бы перейти в индексы phyton

#Создаем списки
visit = [False] * max_top #посещенные вершины (изначально заложено отрицательное булевое значение - ложь)
distance = [float('inf')] * max_top #список расстояний до каждой вершины, изначально задано положительной бесконенчостью, как максимальное значение

distance[start_top] = 0 #сразу определяем расстояние до стартовой вершины равное 0 (сама в себе)

for i in range(max_top): #первый выбор вершины
  u = None
  min_dist = float('inf')
  for j in range(max_top): #второй выбор вершины (как бы стоя на одной точке смотрим на другие)
    if not visit[j] and distance[j] < min_dist: #если не посетили и расстояние меньше уже найденного или изначально определенного как бесконечность, то
      min_dist = distance[j] #минимальному расстоянию присваиваем найденное растояние
      u = j
  if u is None:
    break  # все вершины посещены
  for v, L in enumerate(graph_matrix[u]): #третий выбор вершины (как бы встав на вторую точку просматриваем путь дальше)
    if v != start_top and L > 0 and not visit[v]: #проверяем длину расстояния до вершины и были мы там или нет (при этом не возвращаемся на точку, на которую встали в первый раз, )
      new_dist = distance[u] + L
      if new_dist < distance[v]:
        distance[v] = new_dist
  visit[u] = True #помечаем выбранную вершину как посещённую

print(f"\nКратчайшие расстояния от вершины {start_top+1}:")
for i, dist in enumerate(distance):
  if dist == float('inf'):
    print(f"До вершины {i + 1} добраться нельзя.")
  if dist != 0: #убираем из вывода стартовую вершину, выводим только все остальные
    print(f"До вершины {i + 1} — {dist}")